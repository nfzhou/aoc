% https://adventofcode.com/2024/day/24, part-2
% almost there, but 

import util, sat.

main([File]) =>
    Lines = read_file_lines(File),
    WireDict = new_map(),
    proc_input(Lines,1,WireDict,Gates),
    N = size(WireDict),
    WireA = new_array(N),
    foreach (W in values(WireDict))   % convert WireDict to WireA
        W = {Num,_,_},
    WireA[Num] = W
    end,
    SwapM = new_array(N,N),      % SwapM[I,J] iff wire I and wire J are swapped
    SwapM :: 0..1,
    foreach (I in 1..N)
        SwapM[I,I] = 0,
    	WireA[I] = {_,_,InSwapI},
    	InSwapI #= sum([SwapM[I,J] : J in 1..N]),
        foreach (J in I+1..N)
            SwapM[I,J] = SwapM[J,I],
            WireA[J] = {_,_,InSwapJ},    
            SwapM[I,J] #=> InSwapI #/\ InSwapJ
        end
    end,
    sum([SwapM[I,J] : I in 1..N, J in I+1..N]) #= 4,
    Ws = sort(keys(WireDict)),
    sum([InSwapI :  W in Ws, WireDict.get(W) = {_,_,InSwap}]) #= 8,
    VA = new_array(N),   % wire values after swappings
    VA :: 0..1,
    foreach (I in 1..N)
        retrieve_value(SwapM,N,I,WireA,SwapM,VA[I])
    end,
    foreach ({Type,I1,I2,Out} in Gates)
        constrain_gate(Type,WireA[I1],WireA[I2],WireA[Out])
    end,
    XWs = [(W,to_int(PStr)) : W in Ws, W = ['x'|PStr]],
    YWs = [(W,to_int(PStr)) : W in Ws, W = ['y'|PStr]],
    ZWs = [(W,to_int(PStr)) : W in Ws, W = ['z'|PStr]],
/*    
    writeln(XWs),
    writeln(YWs),
    writeln(ZWs),
*/    
    X #= sum([VA[I]*2**P : (W,P) in XWs, {I,_,_} = WireDict.get(W)]),
    Y #= sum([VA[I]*2**P : (W,P) in YWs, {I,_,_} = WireDict.get(W)]),
    Z #= sum([VA[I]*2**P : (W,P) in ZWs, {I,_,_} = WireDict.get(W)]),
    println(X+Y #= Z),
    X+Y #= Z,

    println(VA),
    Bs = values(WireDict),
    
    writeln(solving),    
    solve((Bs,SwapM,VA)),
    L = join(sort([W :  W in keys(WireDict), WireDict.get(W) = {_,_,1}]), ","),
    println(L).


proc_input([],WNum,WireDict,Gates) =>
    Gates = [].
proc_input([Line|Lines],WNum,WireDict,Gates),
    append(Token1,[':'|Token2],Line)
=>
    W = strip(Token1),
    Val = to_int(Token2),
    InSwap = 0, % an input wire cannot be swapped
    WireDict.put(W, {WNum,Val,InSwap}),
    proc_input(Lines,WNum+1,WireDict,Gates).
proc_input([Line|Lines],WNum,WireDict,Gates),
    append(IStr,['-','>'|OStr],Line)
=>    
    extract_gate(IStr,OStr,WNum,WNum1,WireDict,Gate),
    Gates = [Gate|Gates1],
    proc_input(Lines,WNum1,WireDict,Gates1).
proc_input([_|Lines],WNum,WireDict,Gates) =>
    proc_input(Lines,WNum,WireDict,Gates).

extract_gate(IStr,OStr,WNum0,WNum,WireDict,Gate),
    append(Token1, ['X','O','R'|Token2],IStr)
=>
    Gate = {xor,Num1,Num2,NumOut},
    register_wire(strip(Token1),WNum0,WNum1,WireDict,Num1),
    register_wire(strip(Token2),WNum1,WNum2,WireDict,Num2),
    register_wire(strip(OStr),WNum2,WNum,WireDict,NumOut).
extract_gate(IStr,OStr,WNum0,WNum,WireDict,Gate),
    append(Token1, ['O','R'|Token2],IStr)
=>
    Gate = {or,Num1,Num2,NumOut},
    register_wire(strip(Token1),WNum0,WNum1,WireDict,Num1),
    register_wire(strip(Token2),WNum1,WNum2,WireDict,Num2),
    register_wire(strip(OStr),WNum2,WNum,WireDict,NumOut).
extract_gate(IStr,OStr,WNum0,WNum,WireDict,Gate),
    append(Token1, ['A','N','D'|Token2],IStr)
=>
    Gate = {and,Num1,Num2,NumOut},
    register_wire(strip(Token1),WNum0,WNum1,WireDict,Num1),
    register_wire(strip(Token2),WNum1,WNum2,WireDict,Num2),
    register_wire(strip(OStr),WNum2,WNum,WireDict,NumOut).

register_wire(W,Num0,Num,WireDict,ThisNum),
    WireDict.has_key(W)
=>
    Num = Num0,
    {ThisNum,_,_} = WireDict.get(W).
register_wire(W,Num0,Num,WireDict,ThisNum) =>
    ThisNum = Num0,
    Num = Num0+1,
    B :: 0..1,
    InSwap :: 0..1,    
    WireDict.put(W,{ThisNum,B,InSwap}).

% if wire i and wire j are swapped, then wire i takes wire j's value
retrieve_value(SwapM,N,I,WireA,SwapM,V) =>
    WireA[I] = {_,BI,InSwapI},
    #~InSwapI #=> V #= BI,
    foreach (J in 1..N, J != I)
        WireA[J] = {_,BJ,_InSwapJ},
    SwapM[I,J] #=> V #= BJ
    end.

constrain_gate(xor,{_,I1,_},{_,I2,_},{_,O,_}) =>
    O #<=> (I1 #^ I2).
constrain_gate(or,{_,I1,_},{_,I2,_},{_,O,_}) =>
    O #<=> (I1 #\/ I2).
constrain_gate(and,{_,I1,_},{_,I2,_},{_,O,_}) =>
    O #<=> (I1 #/\ I2).
